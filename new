WITH SHIFT_BASE AS (
  SELECT
    PA_FROM AS LGNUM,
    SRC_SYS,
    PA_TO AS SHIFT_START_RAW,          -- e.g. '07:00'
    ZCOMMENT AS TIMEZONE               -- e.g. 'America/New_York'
  FROM SC_MD.INT_SC_MD.T_SC_PARAMETERS
  WHERE PROCESS = 'WMS' AND CATE = 'SHIFT_HR'
),
SHIFT_PARAMS AS (
  -- Generate both DAY and NIGHT starts (night = day + 12h)
  SELECT LGNUM, SRC_SYS, SHIFT_START_RAW, TIMEZONE, 'DAY' AS SHIFT_TYPE
  FROM SHIFT_BASE
  UNION ALL
  SELECT
    LGNUM,
    SRC_SYS,
    TO_CHAR(TIMEADD('HOUR', 12, TO_TIME(SHIFT_START_RAW)), 'HH24:MI') AS SHIFT_START_RAW,
    TIMEZONE,
    'NIGHT' AS SHIFT_TYPE
  FROM SHIFT_BASE
),
BASE AS (
  SELECT
    'NA' AS CC_SOURCE_SYSTEM,
    LGNUM, TANUM, PROCTY, TRART, DOCCAT, REASON,
    GUID_STOCK, LETYP, VLTYP, SLOC_TYPE, VLPLA,
    NLTYP, DLOC_TYPE, NLPLA, VLENR, NLENR,
    MATID, MEINS, WHO, QUEUE, EXCCODE, CONFIRMED_BY,
    CREATED_AT, STARTED_AT, CONFIRMED_AT, CONFIRMED_AT_WH,
    NISTM
  FROM EWM_S4_NA_PROD_DATASHARE.STAGING."/SCWM/ORDIM_C"
  WHERE TOSTAT = 'C' AND TRART IN (1,2,3,4)
),
T_TIMES AS (
  -- Localize to warehouse TZ; use NTZ for comparisons
  SELECT
    R.*,
    SP.TIMEZONE,
    CONVERT_TIMEZONE('UTC', SP.TIMEZONE, TRY_TO_TIMESTAMP(TO_VARCHAR(R.STARTED_AT),   'YYYYMMDDHH24MISS'))::TIMESTAMP_NTZ AS STARTED_AT_TS,
    CONVERT_TIMEZONE('UTC', SP.TIMEZONE, TRY_TO_TIMESTAMP(TO_VARCHAR(R.CONFIRMED_AT), 'YYYYMMDDHH24MISS'))::TIMESTAMP_NTZ AS CONFIRMED_AT_TS,
    CAST(CONVERT_TIMEZONE('UTC', SP.TIMEZONE, TRY_TO_TIMESTAMP(TO_VARCHAR(R.CONFIRMED_AT),'YYYYMMDDHH24MISS')) AS DATE) AS CONFIRMED_LOCAL_DATE,
    COALESCE(
      CONVERT_TIMEZONE('UTC', SP.TIMEZONE, TRY_TO_TIMESTAMP(TO_VARCHAR(R.STARTED_AT),   'YYYYMMDDHH24MISS'))::TIMESTAMP_NTZ,
      CONVERT_TIMEZONE('UTC', SP.TIMEZONE, TRY_TO_TIMESTAMP(TO_VARCHAR(R.CONFIRMED_AT), 'YYYYMMDDHH24MISS'))::TIMESTAMP_NTZ
    ) AS ORDER_TS,
    CURRENT_TIMESTAMP()::TIMESTAMP_NTZ AS CC_UPDATED_DATETIMESTAMP,
    SUM(R.NISTM) OVER (PARTITION BY R.TANUM) AS ACTUAL_QUANTITY
  FROM BASE R
  JOIN (SELECT DISTINCT LGNUM, SRC_SYS, TIMEZONE FROM SHIFT_BASE) SP
    ON SP.LGNUM = R.LGNUM AND SP.SRC_SYS = R.CC_SOURCE_SYSTEM
),
-- Build nearest shift start (consider previous/next day too)
OFFSETS AS (SELECT -1 AS off UNION ALL SELECT 0 UNION ALL SELECT 1),
SHIFT_CHOICES AS (
  SELECT
    T.*,
    P.SHIFT_TYPE,
    P.SHIFT_START_RAW,
    TO_TIMESTAMP_NTZ(
      TO_CHAR(DATEADD(DAY, O.off, T.CONFIRMED_LOCAL_DATE), 'YYYY-MM-DD') || ' ' || P.SHIFT_START_RAW,
      'YYYY-MM-DD HH24:MI'
    ) AS SHIFT_START_TS_CAND,
    ABS(DATEDIFF('minute', T.CONFIRMED_AT_TS, TO_TIMESTAMP_NTZ(
      TO_CHAR(DATEADD(DAY, O.off, T.CONFIRMED_LOCAL_DATE), 'YYYY-MM-DD') || ' ' || P.SHIFT_START_RAW,
      'YYYY-MM-DD HH24:MI'
    ))) AS SHIFT_DIFF_MIN
  FROM T_TIMES T
  JOIN SHIFT_PARAMS P
    ON P.LGNUM = T.LGNUM AND P.SRC_SYS = T.CC_SOURCE_SYSTEM
  JOIN OFFSETS O ON TRUE
),
PICKED_SHIFT AS (
  SELECT *
  FROM (
    SELECT
      S.*,
      ROW_NUMBER() OVER (PARTITION BY S.LGNUM, S.TANUM ORDER BY S.SHIFT_DIFF_MIN ASC) AS RN
    FROM SHIFT_CHOICES S
  )
  WHERE RN = 1
),
-- Sessionize per operator with 5-hour gap threshold
SESSIONIZE AS (
  SELECT
    P.*,
    LAG(P.CONFIRMED_AT_TS) OVER (
      PARTITION BY P.LGNUM, P.CONFIRMED_BY
      ORDER BY P.ORDER_TS, P.CONFIRMED_AT_TS, P.TANUM
    ) AS PREV_CONFIRMED_AT_TS,
    ROW_NUMBER() OVER (
      PARTITION BY P.LGNUM, P.CONFIRMED_BY
      ORDER BY P.ORDER_TS, P.CONFIRMED_AT_TS, P.TANUM
    ) AS OPERATOR_ROW_NUM
  FROM PICKED_SHIFT P
),
SESSIONIZED AS (
  SELECT
    S.*,
    DATEDIFF('minute', S.PREV_CONFIRMED_AT_TS, S.CONFIRMED_AT_TS) AS GAP_MINUTES,
    IFF(
      S.PREV_CONFIRMED_AT_TS IS NULL OR DATEDIFF('minute', S.PREV_CONFIRMED_AT_TS, S.CONFIRMED_AT_TS) > 300,
      1, 0
    ) AS IS_NEW_SESSION
  FROM SESSIONIZE S
),
SESSION_IDS AS (
  SELECT
    X.*,
    SUM(IS_NEW_SESSION) OVER (
      PARTITION BY X.LGNUM, X.CONFIRMED_BY
      ORDER BY X.ORDER_TS, X.CONFIRMED_AT_TS, X.TANUM
      ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS SESSION_SEQ
  FROM SESSIONIZED X
),
SESSION_ENRICH AS (
  SELECT
    S.*,
    FIRST_VALUE(S.SHIFT_START_TS_CAND) OVER (
      PARTITION BY S.LGNUM, S.CONFIRMED_BY, S.SESSION_SEQ
      ORDER BY S.ORDER_TS, S.CONFIRMED_AT_TS, S.TANUM
      ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS SESSION_FIRST_SHIFT_START_TS,
    FIRST_VALUE(S.CONFIRMED_AT_TS) OVER (
      PARTITION BY S.LGNUM, S.CONFIRMED_BY, S.SESSION_SEQ
      ORDER BY S.ORDER_TS, S.CONFIRMED_AT_TS, S.TANUM
      ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS SESSION_FIRST_CONFIRMED_AT_TS
  FROM SESSION_IDS S
),
-- Anchor for time taken: if same hour as shift start → use shift start; else snap to nearest half-hour of confirm time
ANCHORED AS (
  SELECT
    S.*,
    CASE
      WHEN SHIFT_START_TS_CAND IS NOT NULL
       AND DATE_PART('HOUR', CONFIRMED_AT_TS) = DATE_PART('HOUR', SHIFT_START_TS_CAND)
      THEN SHIFT_START_TS_CAND
      WHEN DATE_PART('MINUTE', CONFIRMED_AT_TS) < 30
      THEN DATE_TRUNC('HOUR', CONFIRMED_AT_TS)
      ELSE DATEADD('MINUTE', 30, DATE_TRUNC('HOUR', CONFIRMED_AT_TS))
    END AS EFFECTIVE_ANCHOR_TS
  FROM SESSION_ENRICH S
),
FINAL AS (
  SELECT
    F.LGNUM AS WAREHOUSE_NUMBER,
    F.TANUM AS WAREHOUSE_TASK,
    F.PROCTY AS PROCESS_TYPE,
    F.TRART AS PROCESS_CATEGORY,
    F.DOCCAT AS DOCUMENT_CATEGORY,
    F.REASON AS MOVEMENT_REASON,
    CASE
      WHEN F.PROCTY = '3030' THEN 'REPLENISHMENT'
      WHEN F.PROCTY LIKE '1%' THEN 'INBOUND'
      WHEN F.PROCTY LIKE '2%' THEN 'OUTBOUND'
      ELSE 'OTHERS'
    END AS DIRECTION,
    F.GUID_STOCK AS GUID_STOCK_ITEM,
    F.LETYP AS HANDLING_UNIT_TYPE,
    F.VLTYP AS SOURCE_STORAGE_TYPE,
    F.SLOC_TYPE AS LOCATION_TYPE,
    F.VLPLA AS SOURCE_STORAGE_BIN,
    F.NLTYP AS DEST_STORAGE_TYPE,
    F.DLOC_TYPE AS DEST_LOCATION_TYPE,
    F.NLPLA AS DEST_STORAGE_BIN,
    F.VLENR AS SOURCE_HU,
    F.NLENR AS DEST_HU,
    F.MATID AS PRODUCT_ID,
    F.MEINS AS BASE_UOM,
    F.WHO AS WAREHOUSE_ORDER,
    F.QUEUE,
    F.EXCCODE AS EXCEPTION_CODE,
    F.CONFIRMED_BY,
    F.CREATED_AT AS CREATED_TIMESTAMP,

    F.SHIFT_START_TS_CAND AS SHIFT_START_TS,
    DATEADD('HOUR', 12, F.SHIFT_START_TS_CAND) AS SHIFT_END_TS,

    -- Session id (operator + running session counter)
    F.LGNUM || '-' || F.CONFIRMED_BY || '-' ||
      TO_CHAR(F.SESSION_FIRST_CONFIRMED_AT_TS, 'YYYY-MM-DD"T"HH24:MI') || '-' ||
      LPAD(F.SESSION_SEQ::STRING, 4, '0') AS SHIFT_SESSION_ID,

    F.OPERATOR_ROW_NUM AS OPERATOR_TASK_RANK,

    TO_CHAR(F.STARTED_AT_TS,   'YYYYMMDDHH24MISS') AS STARTED_TIMESTAMP,
    TO_CHAR(F.CONFIRMED_AT_TS, 'YYYYMMDDHH24MISS') AS CONFIRMED_WH_TIMESTAMP,

    F.EFFECTIVE_ANCHOR_TS,
    ABS(DATEDIFF('SECOND', F.EFFECTIVE_ANCHOR_TS, F.CONFIRMED_AT_TS)) AS TIME_TAKEN_IN_SEC,

    -- Diagnostics
    F.GAP_MINUTES,
    F.IS_NEW_SESSION,
    F.SESSION_SEQ,

    F.ACTUAL_QUANTITY,
    'NA' AS CC_SOURCE_SYSTEM,
    F.CC_UPDATED_DATETIMESTAMP
  FROM ANCHORED F
)
SELECT *
FROM FINAL;
dont see confirmed date wh
Thought for 23s
Here’s the same query with CONFIRMED_DATE_WH added (derived from CONFIRMED_AT_WH) and surfaced in the final output.

WITH SHIFT_BASE AS (
  SELECT
    PA_FROM AS LGNUM,
    SRC_SYS,
    PA_TO AS SHIFT_START_RAW,          -- e.g. '07:00'
    ZCOMMENT AS TIMEZONE               -- e.g. 'America/New_York'
  FROM SC_MD.INT_SC_MD.T_SC_PARAMETERS
  WHERE PROCESS = 'WMS' AND CATE = 'SHIFT_HR'
),
SHIFT_PARAMS AS (
  -- Generate both DAY and NIGHT starts (night = day + 12h)
  SELECT LGNUM, SRC_SYS, SHIFT_START_RAW, TIMEZONE, 'DAY' AS SHIFT_TYPE
  FROM SHIFT_BASE
  UNION ALL
  SELECT
    LGNUM,
    SRC_SYS,
    TO_CHAR(TIMEADD('HOUR', 12, TO_TIME(SHIFT_START_RAW)), 'HH24:MI') AS SHIFT_START_RAW,
    TIMEZONE,
    'NIGHT' AS SHIFT_TYPE
  FROM SHIFT_BASE
),
BASE AS (
  SELECT
    'NA' AS CC_SOURCE_SYSTEM,
    LGNUM, TANUM, PROCTY, TRART, DOCCAT, REASON,
    GUID_STOCK, LETYP, VLTYP, SLOC_TYPE, VLPLA,
    NLTYP, DLOC_TYPE, NLPLA, VLENR, NLENR,
    MATID, MEINS, WHO, QUEUE, EXCCODE, CONFIRMED_BY,
    CREATED_AT, STARTED_AT, CONFIRMED_AT, CONFIRMED_AT_WH,
    NISTM
  FROM EWM_S4_NA_PROD_DATASHARE.STAGING."/SCWM/ORDIM_C"
  WHERE TOSTAT = 'C' AND TRART IN (1,2,3,4)
),
T_TIMES AS (
  -- Localize to warehouse TZ; use NTZ for comparisons
  SELECT
    R.*,
    SP.TIMEZONE,
    CONVERT_TIMEZONE('UTC', SP.TIMEZONE, TRY_TO_TIMESTAMP(TO_VARCHAR(R.STARTED_AT),   'YYYYMMDDHH24MISS'))::TIMESTAMP_NTZ AS STARTED_AT_TS,
    CONVERT_TIMEZONE('UTC', SP.TIMEZONE, TRY_TO_TIMESTAMP(TO_VARCHAR(R.CONFIRMED_AT), 'YYYYMMDDHH24MISS'))::TIMESTAMP_NTZ AS CONFIRMED_AT_TS,
    CAST(CONVERT_TIMEZONE('UTC', SP.TIMEZONE, TRY_TO_TIMESTAMP(TO_VARCHAR(R.CONFIRMED_AT),'YYYYMMDDHH24MISS')) AS DATE) AS CONFIRMED_LOCAL_DATE,
    -- WH date from CONFIRMED_AT_WH (as provided)
    TRY_TO_DATE(LEFT(R.CONFIRMED_AT_WH, 8), 'YYYYMMDD') AS CONFIRMED_DATE_WH,
    COALESCE(
      CONVERT_TIMEZONE('UTC', SP.TIMEZONE, TRY_TO_TIMESTAMP(TO_VARCHAR(R.STARTED_AT),   'YYYYMMDDHH24MISS'))::TIMESTAMP_NTZ,
      CONVERT_TIMEZONE('UTC', SP.TIMEZONE, TRY_TO_TIMESTAMP(TO_VARCHAR(R.CONFIRMED_AT), 'YYYYMMDDHH24MISS'))::TIMESTAMP_NTZ
    ) AS ORDER_TS,
    CURRENT_TIMESTAMP()::TIMESTAMP_NTZ AS CC_UPDATED_DATETIMESTAMP,
    SUM(R.NISTM) OVER (PARTITION BY R.TANUM) AS ACTUAL_QUANTITY
  FROM BASE R
  JOIN (SELECT DISTINCT LGNUM, SRC_SYS, TIMEZONE FROM SHIFT_BASE) SP
    ON SP.LGNUM = R.LGNUM AND SP.SRC_SYS = R.CC_SOURCE_SYSTEM
),
-- Build nearest shift start (consider previous/next day too)
OFFSETS AS (SELECT -1 AS off UNION ALL SELECT 0 UNION ALL SELECT 1),
SHIFT_CHOICES AS (
  SELECT
    T.*,
    P.SHIFT_TYPE,
    P.SHIFT_START_RAW,
    TO_TIMESTAMP_NTZ(
      TO_CHAR(DATEADD(DAY, O.off, T.CONFIRMED_LOCAL_DATE), 'YYYY-MM-DD') || ' ' || P.SHIFT_START_RAW,
      'YYYY-MM-DD HH24:MI'
    ) AS SHIFT_START_TS_CAND,
    ABS(DATEDIFF('minute', T.CONFIRMED_AT_TS, TO_TIMESTAMP_NTZ(
      TO_CHAR(DATEADD(DAY, O.off, T.CONFIRMED_LOCAL_DATE), 'YYYY-MM-DD') || ' ' || P.SHIFT_START_RAW,
      'YYYY-MM-DD HH24:MI'
    ))) AS SHIFT_DIFF_MIN
  FROM T_TIMES T
  JOIN SHIFT_PARAMS P
    ON P.LGNUM = T.LGNUM AND P.SRC_SYS = T.CC_SOURCE_SYSTEM
  JOIN OFFSETS O ON TRUE
),
PICKED_SHIFT AS (
  SELECT *
  FROM (
    SELECT
      S.*,
      ROW_NUMBER() OVER (PARTITION BY S.LGNUM, S.TANUM ORDER BY S.SHIFT_DIFF_MIN ASC) AS RN
    FROM SHIFT_CHOICES S
  )
  WHERE RN = 1
),
-- Sessionize per operator with 5-hour gap threshold
SESSIONIZE AS (
  SELECT
    P.*,
    LAG(P.CONFIRMED_AT_TS) OVER (
      PARTITION BY P.LGNUM, P.CONFIRMED_BY
      ORDER BY P.ORDER_TS, P.CONFIRMED_AT_TS, P.TANUM
    ) AS PREV_CONFIRMED_AT_TS,
    ROW_NUMBER() OVER (
      PARTITION BY P.LGNUM, P.CONFIRMED_BY
      ORDER BY P.ORDER_TS, P.CONFIRMED_AT_TS, P.TANUM
    ) AS OPERATOR_ROW_NUM
  FROM PICKED_SHIFT P
),
SESSIONIZED AS (
  SELECT
    S.*,
    DATEDIFF('minute', S.PREV_CONFIRMED_AT_TS, S.CONFIRMED_AT_TS) AS GAP_MINUTES,
    IFF(
      S.PREV_CONFIRMED_AT_TS IS NULL OR DATEDIFF('minute', S.PREV_CONFIRMED_AT_TS, S.CONFIRMED_AT_TS) > 300,
      1, 0
    ) AS IS_NEW_SESSION
  FROM SESSIONIZE S
),
SESSION_IDS AS (
  SELECT
    X.*,
    SUM(IS_NEW_SESSION) OVER (
      PARTITION BY X.LGNUM, X.CONFIRMED_BY
      ORDER BY X.ORDER_TS, X.CONFIRMED_AT_TS, X.TANUM
      ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS SESSION_SEQ
  FROM SESSIONIZED X
),
SESSION_ENRICH AS (
  SELECT
    S.*,
    FIRST_VALUE(S.SHIFT_START_TS_CAND) OVER (
      PARTITION BY S.LGNUM, S.CONFIRMED_BY, S.SESSION_SEQ
      ORDER BY S.ORDER_TS, S.CONFIRMED_AT_TS, S.TANUM
      ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS SESSION_FIRST_SHIFT_START_TS,
    FIRST_VALUE(S.CONFIRMED_AT_TS) OVER (
      PARTITION BY S.LGNUM, S.CONFIRMED_BY, S.SESSION_SEQ
      ORDER BY S.ORDER_TS, S.CONFIRMED_AT_TS, S.TANUM
      ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS SESSION_FIRST_CONFIRMED_AT_TS
  FROM SESSION_IDS S
),
-- Anchor for time taken: if same hour as shift start → use shift start; else snap to nearest half-hour of confirm time
ANCHORED AS (
  SELECT
    S.*,
    CASE
      WHEN SHIFT_START_TS_CAND IS NOT NULL
       AND DATE_PART('HOUR', CONFIRMED_AT_TS) = DATE_PART('HOUR', SHIFT_START_TS_CAND)
      THEN SHIFT_START_TS_CAND
      WHEN DATE_PART('MINUTE', CONFIRMED_AT_TS) < 30
      THEN DATE_TRUNC('HOUR', CONFIRMED_AT_TS)
      ELSE DATEADD('MINUTE', 30, DATE_TRUNC('HOUR', CONFIRMED_AT_TS))
    END AS EFFECTIVE_ANCHOR_TS
  FROM SESSION_ENRICH S
),
FINAL AS (
  SELECT
    F.LGNUM AS WAREHOUSE_NUMBER,
    F.TANUM AS WAREHOUSE_TASK,
    F.PROCTY AS PROCESS_TYPE,
    F.TRART AS PROCESS_CATEGORY,
    F.DOCCAT AS DOCUMENT_CATEGORY,
    F.REASON AS MOVEMENT_REASON,
    CASE
      WHEN F.PROCTY = '3030' THEN 'REPLENISHMENT'
      WHEN F.PROCTY LIKE '1%' THEN 'INBOUND'
      WHEN F.PROCTY LIKE '2%' THEN 'OUTBOUND'
      ELSE 'OTHERS'
    END AS DIRECTION,
    F.GUID_STOCK AS GUID_STOCK_ITEM,
    F.LETYP AS HANDLING_UNIT_TYPE,
    F.VLTYP AS SOURCE_STORAGE_TYPE,
    F.SLOC_TYPE AS LOCATION_TYPE,
    F.VLPLA AS SOURCE_STORAGE_BIN,
    F.NLTYP AS DEST_STORAGE_TYPE,
    F.DLOC_TYPE AS DEST_LOCATION_TYPE,
    F.NLPLA AS DEST_STORAGE_BIN,
    F.VLENR AS SOURCE_HU,
    F.NLENR AS DEST_HU,
    F.MATID AS PRODUCT_ID,
    F.MEINS AS BASE_UOM,
    F.WHO AS WAREHOUSE_ORDER,
    F.QUEUE,
    F.EXCCODE AS EXCEPTION_CODE,
    F.CONFIRMED_BY,
    F.CREATED_AT AS CREATED_TIMESTAMP,

    F.SHIFT_START_TS_CAND AS SHIFT_START_TS,
    DATEADD('HOUR', 12, F.SHIFT_START_TS_CAND) AS SHIFT_END_TS,

    -- Session id (operator + running session counter)
    F.LGNUM || '-' || F.CONFIRMED_BY || '-' ||
      TO_CHAR(F.SESSION_FIRST_CONFIRMED_AT_TS, 'YYYY-MM-DD"T"HH24:MI') || '-' ||
      LPAD(F.SESSION_SEQ::STRING, 4, '0') AS SHIFT_SESSION_ID,

    F.OPERATOR_ROW_NUM AS OPERATOR_TASK_RANK,

    TO_CHAR(F.STARTED_AT_TS,   'YYYYMMDDHH24MISS') AS STARTED_TIMESTAMP,
    TO_CHAR(F.CONFIRMED_AT_TS, 'YYYYMMDDHH24MISS') AS CONFIRMED_WH_TIMESTAMP,

    -- requested
    F.CONFIRMED_DATE_WH,

    F.EFFECTIVE_ANCHOR_TS,
    ABS(DATEDIFF('SECOND', F.EFFECTIVE_ANCHOR_TS, F.CONFIRMED_AT_TS)) AS TIME_TAKEN_IN_SEC,

    -- Diagnostics
    F.GAP_MINUTES,
    F.IS_NEW_SESSION,
    F.SESSION_SEQ,

    F.ACTUAL_QUANTITY,
    'NA' AS CC_SOURCE_SYSTEM,
    F.CC_UPDATED_DATETIMESTAMP
  FROM ANCHORED F
)
SELECT *
FROM FINAL;
